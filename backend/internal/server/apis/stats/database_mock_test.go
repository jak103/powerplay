// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package stats

import (
	"github.com/jak103/powerplay/internal/models"
	"sync"
)

// Ensure, that sessionMock does implement session.
// If this is not the case, regenerate this file with moq.
var _ session = &sessionMock{}

// sessionMock is a mock implementation of session.
//
//	func TestSomethingThatUsessession(t *testing.T) {
//
//		// make and configure a mocked session
//		mockedsession := &sessionMock{
//			GetGoalsFunc: func() ([]models.Goal, error) {
//				panic("mock out the GetGoals method")
//			},
//			SaveGoalFunc: func(goal *models.Goal) (*models.Goal, error) {
//				panic("mock out the SaveGoal method")
//			},
//		}
//
//		// use mockedsession in code that requires session
//		// and then make assertions.
//
//	}
type sessionMock struct {
	// GetGoalsFunc mocks the GetGoals method.
	GetGoalsFunc func() ([]models.Goal, error)

	// SaveGoalFunc mocks the SaveGoal method.
	SaveGoalFunc func(goal *models.Goal) (*models.Goal, error)

	// calls tracks calls to the methods.
	calls struct {
		// GetGoals holds details about calls to the GetGoals method.
		GetGoals []struct {
		}
		// SaveGoal holds details about calls to the SaveGoal method.
		SaveGoal []struct {
			// Goal is the goal argument value.
			Goal *models.Goal
		}
	}
	lockGetGoals sync.RWMutex
	lockSaveGoal sync.RWMutex
}

// GetGoals calls GetGoalsFunc.
func (mock *sessionMock) GetGoals() ([]models.Goal, error) {
	if mock.GetGoalsFunc == nil {
		panic("sessionMock.GetGoalsFunc: method is nil but session.GetGoals was just called")
	}
	callInfo := struct {
	}{}
	mock.lockGetGoals.Lock()
	mock.calls.GetGoals = append(mock.calls.GetGoals, callInfo)
	mock.lockGetGoals.Unlock()
	return mock.GetGoalsFunc()
}

// GetGoalsCalls gets all the calls that were made to GetGoals.
// Check the length with:
//
//	len(mockedsession.GetGoalsCalls())
func (mock *sessionMock) GetGoalsCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockGetGoals.RLock()
	calls = mock.calls.GetGoals
	mock.lockGetGoals.RUnlock()
	return calls
}

// SaveGoal calls SaveGoalFunc.
func (mock *sessionMock) SaveGoal(goal *models.Goal) (*models.Goal, error) {
	if mock.SaveGoalFunc == nil {
		panic("sessionMock.SaveGoalFunc: method is nil but session.SaveGoal was just called")
	}
	callInfo := struct {
		Goal *models.Goal
	}{
		Goal: goal,
	}
	mock.lockSaveGoal.Lock()
	mock.calls.SaveGoal = append(mock.calls.SaveGoal, callInfo)
	mock.lockSaveGoal.Unlock()
	return mock.SaveGoalFunc(goal)
}

// SaveGoalCalls gets all the calls that were made to SaveGoal.
// Check the length with:
//
//	len(mockedsession.SaveGoalCalls())
func (mock *sessionMock) SaveGoalCalls() []struct {
	Goal *models.Goal
} {
	var calls []struct {
		Goal *models.Goal
	}
	mock.lockSaveGoal.RLock()
	calls = mock.calls.SaveGoal
	mock.lockSaveGoal.RUnlock()
	return calls
}
